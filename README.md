# 羊と狼パズルをSpinで解く

## 方針
なるべくシンプルに。

* 通信チャネルは使わない。大域変数のみ使う。

## ゲームのモデリング

### 登場人物

* 羊
* 狼
* 舟
* 岸A
* 岸B

### 必要な変数

* 羊: 岸A, 舟, 岸B それぞれの人数 (lambA, lambS, lambB)
* 狼: 　　　　　　〃　　　　　　 (wolfA, wolfS, wolfB)
* 舟: どちらの岸にいるか (ship)

### 振る舞い

* 舟がいる岸で，岸から舟に羊・狼が移動できる (定員2名)。
* 舟に1人以上乗っていたら舟を向こう岸に移動できる。
  * 移動したら乗員は一旦岸に移動する。
* 岸AまたはBにいる羊の数は0か同じ岸の狼の数以上。

下記は検証項目 (LTL式) で表す:

* 岸Bに全員移動したらゲームクリア

## Promela化

```
/* ゲームクリアの条件 */
#define goal  (lambB == N && wolfB == N)

#define N              3  /* 羊・狼 各人数 */
#define SHIP_CAPACITY  2  /* 舟の定員 */

#define BANK_A  0               /* 舟が岸Aにいる */
#define BANK_B  1               /* 舟が岸Bにいる */
#define OPP_BANK(b)  (1 - (b))  /* 向こう岸 */
#define N_CREW  (lambS + wolfS) /* 乗員数 */

byte lambA = N, lambS = 0, lambB = 0;
byte wolfA = N, wolfS = 0, wolfB = 0;
byte ship = BANK_A;

active proctype Game() {
  do
  :: 舟が岸Aにいる かつ 舟に空きがある ->
     羊か狼かどちらかを一人舟に移す
  :: 舟が岸Bにいる かつ 舟に空きがある ->
     羊か狼かどちらかを一人舟に移す
  :: 舟に誰か乗っている かつ 羊が安全 ->
     舟を向こう岸に移動;
     乗員を舟から岸に下ろす;
     羊が安全 (そうでなければここで停止)
  od
}
```

(岸に羊と狼が二人ずついて，羊二人を舟に乗せる場合，上の疑似コードのように一人ずつ乗せると一時「羊が安全でない」状態になる。「羊が安全」かどうか調べる位置には注意が必要。)

## 検証による求解

### LTL式による検証

`<> goal` をnever claim化して検証 <br />
( `!<> goal` であることを検証 → goal に到達する実行系列を反例)。

```
$ spin -f '<> goal' >wolf.ltl      -- never claim生成
$ spin -a -N wolf.ltl wolf.pml     -- pan.cを生成
$ cc -O -DSAFETY pan.c -o pan      -- panをコンパイル
$ ./pan                            -- 検証
$ spin -t -p -g wolf.pml           -- 実行系列を表示
```

### 余談：assertによる検証

「goalに到達可能か」は安全性に関する検証なので，assertでも容易に検証できる。

`assert !goal` を適切な箇所に挿入すればよい。
上記の疑似コードでは，「羊が安全 (そうでなければここで停止)」の直後に挿入すれば，1箇所だけで済む。
<br />
(LTL式による検証は「すべての位置に `assert !goal` を書く」のと同じなので，より強力。)

assertによる検証の際は，不正end状態の検査をしないよう指示する必要がある:

  * `pan`を実行するときに `-E`オプションを付ける。または，
  * 「羊が安全 (そうでなければここで停止)」と`do` (舟に空きがない かつ 羊が安全でない場合に選択肢がない) にendラベルを付ける。

### 余談：複数のプロセス

複雑なパズルを扱う際は，小さい仕事をするプロセスに分けてモデリングした方が見通しがよくなる。

ただし，無用なインターリーブが起きないように，`atomic` または `d_step` を適切に使う必要がある。<br />
(「動かせるかどうか調べる」ステップと「動かす」ステップの間に他のプロセスが割り込むと，想定していない振る舞いをしてしまう。)

```
active proctype BankA() {
  do
  :: d_step {
       舟が岸Aにいる かつ 舟に空きがある かつ
       羊が岸Aに一人以上いる ->
       羊を一人舟に移す
     }
  :: d_step {
       舟が岸Aにいる かつ 舟に空きがある かつ
       狼が岸Aに一人以上いる ->
       狼を一人舟に移す
     }
  od
}

active proctype BankB() {
  BankAと同様
}

active proctype Ship() {
  do
  :: d_step {
       舟に誰か乗っている かつ 羊が安全 ->
       舟を向こう岸に移動;
       乗員を舟から岸に下ろす
     };
     羊が安全 (そうでなければここで停止)
  od
}
```

`d_step` の方が検証効率がよい (このパズルでは大差ないが，プロセス数が増えると差が大きくなる)。
ただし，`d_step` は「途中で非決定的選択ができない」「停止するかも知れない文 (上記の「羊が安全」など) を途中に書けない」という制約がある。

## 演習課題

1. Promelaコードを完成させ，検証によってパズルの解を求めなさい。正しい解であることを確認しなさい。<br />
(実行系列をわかりやすくするために適当なprintfを挿入しても構わない。)
2. 解に至る最短手順を求めさせるにはどうすればよいか考え，実装しなさい。
